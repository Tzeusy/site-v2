---
title: "Understanding Async Boundaries"
date: 2026-01-12
summary: "Where to draw asynchronous seams so failures stay local and behavior remains predictable."
tags: ["reliability", "distributed-systems", "async", "idempotency"]
---

## Async Boundaries Are Product Boundaries

Every queue, webhook, and retry loop creates a new behavior surface. If you
cannot explain where that boundary starts and ends, users feel the ambiguity as
latency, duplicate actions, or stale state.

## Design for Replay

Idempotency is not a backend detail. It is the difference between a harmless
retry and customer-visible corruption.

```ts
export async function processEvent(eventId: string, payload: string) {
  const alreadyHandled = await db.events.findFirst({ where: { eventId } });
  if (alreadyHandled) return;

  await db.$transaction([
    db.events.create({ data: { eventId } }),
    db.orders.update({ where: { id: payload }, data: { status: "processed" } }),
  ]);
}
```

## Instrument the Gap

Track both ends of an async hop: enqueue timestamp and completion timestamp.
Without both, you cannot distinguish a slow consumer from a dropped message.
