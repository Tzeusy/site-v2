---
title: "Homelab Motivations"
date: 2026-02-08
summary: "Thoughts on why I spend so much time running my own homelab"
tags: ["homelab", "active", "size-2", "draft", "infra"]
---

# Why a homelab?

I've always been fascinated by homelabs, as they've always represented an opportunity for me to explore and learn about technical system infrastructure without the demands of a day job. The main goal of my homelab is to:

1. Education:
    - A personal sandbox to try any and all open source softwareI'm curious about.
    - An opportunity to interact with hardware, expanding my domain knowledge around spaces where my job doesn't take me
2. Firewalled data haven for personal infrastructure (smart home setups, microservices)
3. An environment to 'export' my personal learnings and growth over time, as I gain more experience as a Software Engineer and a SRE.
    - As my work exposes me to new systems and services (Airflow, etc.) I want to concretize/experiment my lessons, and running my own infra is the best way to enable that in a cheap and riskless manner.
4. Experimentation
    - Corporate infrastructure is often months or even years behind the latest and greatest industry offerings, due to bureaucracy, legacy code, and simply misaligned incentives. It takes months for me to get a Python packaged approved internally within the firm, and that's *pre-validation* when I can't guarantee the potential benefits; how else am I to understand new libraries and offerings?
    - Most recently: I've been having *so much fun* at home with Claude and Codex recently that I dread going back to my company's Gemini-only AI ecosystem :sad:

In fact, when mentoring junior engineers and interns, I've frequently mentioned homelabs as a fantastic mode of exploration, when they ask about how best to hone their skills and well-roundedness as software engineers. Software *architecture* design is an instinct you only really pick up with thousands of hours of interaction and understanding; what better way to gain access to these hours, when you only really see these in bursts of a few hours at a time every few weeks at work?

# Requirements

Given the abovementioned goals, my homelab has to be able to:

1. Be able to trivially scale-up and scale-down open-source infrastructure (docker images, helm charts, native builds off git repositories)
2. Provide some semblance of security; 
    - Network firewalling, to reduce risks of data exfiltration (admittedly this is a little tough for me and I haven't focused on this as much as I should've)
    - Using *mirrors* for pypi packages, docker images, etc. to snapshot images
    - Also a way for me to understand how these things are usually done on a corporate level
3. Support infrastructure and applications with drastically varying requirements (CPU, RAM, GPU, heck, even CPU architectures)

In addition, given my background as an SRE, meta-level requirements can also come into play:

1. How fragile and how performant are the services I'm running?
2. How do I gain visibility over what I'm running in my system? How do all the components wire together?
3. What are current best practices on how these requirements are currently met for production infrastructure?

Most experienced SWEs and SREs today would be able to answer these questions for their respective corporate environments; however, these are skills and bits of knowledge picked up over years of experience, and running my own homelab is a good way to bootstrap + experiment with these instincts. 

# Forced Learnings

I come from an application-focused software engineering background and education; in fact, given that my school was relatively application and design focused, one might say I had even less exposure than the average fresh SWE going into my career. For example,

- I stepped into my first job having not much clue about networking concepts (A records, CNAMEs), Kubernetes, platforms like NGINX.
- I never really understood the motivation for the firm's usage of platforms like Consul and Nomad for the management of K/Vs and job/node scheduling
- An instinctive fear of Kafka: a mysterious and hostile CLI, impossibility of extracting useful messages, convoluted client code

As a software engineer, it's always a daunting feeling when you're thrust into an environment where these `<Service Name Nouns>` are slung around, and we're expected to build on top of these platform to enhance features or fix production bugs; there's so much to learn, and the inevitable hours of exploration makes me feel like "what's worth an hour of work" actually consumed me a day of research. Obviously these things are personally beneficial, and detrimental to the company; and perhaps one might say those are reasons to keep learning on company time. However, my goal isn't to eke out as much from a company as possible; it's to *grow*, and so the daunting feeling persists.

This idea of 'playing with things yourself' crops up as a topic every now and then; a previous (fantastic) manager of mine was great at suggesting ideas to try. Of note:

- `socat` + `tcpdump` + `wireshark` to intercept network packets to understand the serialization mechanism of gRPC
- Experimenting with CLI libraries for ease-of-implementation for complicated workflows,
- Reading code of other teams to understand rather than being frustrated at the opaqueness of their APIs
- Experimentation and ideas with LLM architecture and orchestration
- Ideas on microservice (or even monolithic service) design - threading mechanisms, asynchronous paradigms and cooperative thread, single-threaded bottleneck pools to avoid mutex contention, etc.;

I've found that my homelab has been equally productive in teaching me about these things; for example:

- The complexity of managing distributed job systems - Kubernetes cronjobs? Airflow DAGs? etc.
- Understanding the hardware abstraction layer that is Kubernetes, and the rough edges where these things tend to cause unintuitive gaps in functionality
    - Local versus NFS based storage provisioning, especially when it comes to performance
- Lessons on telemetry, the overheads of maintaining an OTel platform, the benefits
- Networking, and the magic of Tailscale
- Storage: Performance of HDDs, SSDs, RAID configurations, and how they work in a NAS
